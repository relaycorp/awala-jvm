package tech.relaycorp.relaynet.wrappers.x509

import java.math.BigInteger
import java.sql.Date
import java.time.LocalDate
import java.time.LocalDateTime
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertTrue
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.assertThrows
import tech.relaycorp.relaynet.wrappers.generateRSAKeyPair

class CertificateTest {
    private val stubCommonName = "The CommonName"
    private val stubKeyPair = generateRSAKeyPair()

    @Test
    fun `Certificate version should be 3`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(3, certificate.certificateHolder.versionNumber)
    }

    @Test
    fun `Subject public key should be the specified one`() {
        val validityStartDate = LocalDateTime.now().plusMonths(1)
        val validityEndDate = LocalDateTime.now().plusMonths(2)
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public,
            validityStartDate,
            validityEndDate
        )

        assertEquals(
            stubKeyPair.public.encoded.asList(),
            certificate.certificateHolder.subjectPublicKeyInfo.encoded.asList()
        )
    }

    @Test
    fun `Certificate should be signed with issuer private key`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assert(
            certificate.certificateHolder.isSignatureValid(JcaContentVerifierProviderBuilder().build(stubKeyPair.public))
        )
    }

    @Test
    fun `Serial number should be autogenerated`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assert(certificate.certificateHolder.serialNumber > BigInteger.ZERO)
    }

    @Test
    fun `Validity start date should be set to current time by default`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(
            Date.valueOf(LocalDate.now()),
            certificate.certificateHolder.notBefore
        )
    }

    // TODO: There shouldn't be any default end date. It must be explicit.
    @Test
    fun testShouldHaveAValidDefaultEndDate() {
        val newCertificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertTrue(
            newCertificate.certificateHolder.notAfter > Date.valueOf(LocalDate.now()),
            "Should create a certificate end date after now"
        )
    }

    @Test
    fun `The end date should be later than the start date`() {
        val validityStartDate = LocalDateTime.now().plusMonths(1)

        val exception = assertThrows<CertificateException> {
            Certificate.issue(
                stubCommonName,
                stubKeyPair.private,
                stubKeyPair.public,
                validityStartDate,
                validityStartDate // Same as start date
            )
        }
        assertEquals(
            "The end date must be later than the start date",
            exception.message
        )
    }

    @Test
    fun `Subject DN should be set to specified CN`() {
        val commonName = "The CN"
        val certificate = Certificate.issue(
            commonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(1, certificate.certificateHolder.subject.rdNs.size)
        assertEquals(false, certificate.certificateHolder.subject.rdNs[0].isMultiValued)
        assertEquals(commonName, certificate.certificateHolder.subject.rdNs[0].first.value.toString())
    }

    @Test
    fun `Issuer DN should be same as subject when certificate is self-issued`() {
        val commonName = "The CN"
        val certificate = Certificate.issue(
            commonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(1, certificate.certificateHolder.issuer.rdNs.size)
        assertEquals(false, certificate.certificateHolder.issuer.rdNs[0].isMultiValued)
        assertEquals(commonName, certificate.certificateHolder.issuer.rdNs[0].first.value.toString())
    }

    @Nested
    inner class IssuerCertificate {
        @Test
        @Disabled
        fun `Issuer DN should be set to subject of issuer certificate`() {
        }

        @Test
        @Disabled
        fun `Issuer certificate should have basicConstraints extension`() {
        }

        @Test
        @Disabled
        fun `Issuer certificate should be marked as CA`() {
        }
    }

    @Nested
    inner class BasicConstraintsExtension {
        private val extensionOid = "2.5.29.19"

        @Test
        fun `Extension should be included and marked as critical`() {
            val certificate = Certificate.issue(
                stubCommonName,
                stubKeyPair.private,
                stubKeyPair.public
            )

            assert(certificate.certificateHolder.hasExtensions())
            val extension = certificate.certificateHolder.getExtension(ASN1ObjectIdentifier(extensionOid))
            assert(extension is Extension)
            assert(extension.isCritical)
        }

        @Test
        fun `CA flag should be false by default`() {
            val certificate = Certificate.issue(
                stubCommonName,
                stubKeyPair.private,
                stubKeyPair.public
            )

            val basicConstraints = BasicConstraints.fromExtensions(certificate.certificateHolder.extensions)
            assertFalse(basicConstraints.isCA)
        }

        @Test
        fun `CA flag should be enabled if requested`() {
            val certificate = Certificate.issue(
                stubCommonName,
                stubKeyPair.private,
                stubKeyPair.public,
                isCA = true
            )

            assert(
                BasicConstraints.fromExtensions(certificate.certificateHolder.extensions).isCA
            )
        }

        @Test
        fun `pathLenConstraint should be 0 by default`() {
            val certificate = Certificate.issue(
                stubCommonName,
                stubKeyPair.private,
                stubKeyPair.public
            )

            val basicConstraints = BasicConstraints.fromExtensions(
                certificate.certificateHolder.extensions
            )
            assertEquals(
                0,
                basicConstraints.pathLenConstraint.toInt()
            )
        }

        @Test
        fun `pathLenConstraint can be set to a custom value of up to 2`() {
            val certificate = Certificate.issue(
                stubCommonName,
                stubKeyPair.private,
                stubKeyPair.public,
                pathLenConstraint = 2
            )

            val basicConstraints = BasicConstraints.fromExtensions(
                certificate.certificateHolder.extensions
            )
            assertEquals(
                2,
                basicConstraints.pathLenConstraint.toInt()
            )
        }

        @Test
        fun `pathLenConstraint should not be greater than 2`() {
            val exception = assertThrows<CertificateException> {
                Certificate.issue(
                    stubCommonName,
                    stubKeyPair.private,
                    stubKeyPair.public,
                    pathLenConstraint = 3
                )
            }

            assertEquals("pathLenConstraint should be between 0 and 2 (got 3)", exception.message)
        }

        @Test
        fun `pathLenConstraint should not be negative`() {
            val exception = assertThrows<CertificateException> {
                Certificate.issue(
                    stubCommonName,
                    stubKeyPair.private,
                    stubKeyPair.public,
                    pathLenConstraint = -1
                )
            }

            assertEquals("pathLenConstraint should be between 0 and 2 (got -1)", exception.message)
        }
    }

    @Nested
    inner class AuthorityKeyIdentifier {
        @Test
        @Disabled
        fun `Value should correspond to subject when self-issued`() {
        }

        @Test
        @Disabled
        fun `Value should correspond to issuer when issued by a CA`() {
        }
    }

    @Test
    @Disabled
    fun `Subject Key Identifier extension should correspond to subject key`() {
    }
}
