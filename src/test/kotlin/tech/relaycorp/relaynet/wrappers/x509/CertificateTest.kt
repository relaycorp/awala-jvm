package tech.relaycorp.relaynet.wrappers.x509

import java.math.BigInteger
import java.sql.Date
import java.time.LocalDate
import java.time.LocalDateTime
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue
import org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.assertThrows
import tech.relaycorp.relaynet.wrappers.generateRSAKeyPair

class CertificateTest {
    private val stubCommonName = "The CommonName"
    private val stubKeyPair = generateRSAKeyPair()

    @Test
    fun `Certificate version should be 3`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(3, certificate.certificateHolder.versionNumber)
    }

    @Test
    fun `Subject public key should be the specified one`() {
        val validityStartDate = LocalDateTime.now().plusMonths(1)
        val validityEndDate = LocalDateTime.now().plusMonths(2)
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public,
            validityStartDate,
            validityEndDate
        )

        assertEquals(
            stubKeyPair.public.encoded.asList(),
            certificate.certificateHolder.subjectPublicKeyInfo.encoded.asList()
        )
    }

    @Test
    fun `Certificate should be signed with issuer private key`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assert(
            certificate.certificateHolder.isSignatureValid(JcaContentVerifierProviderBuilder().build(stubKeyPair.public))
        )
    }

    @Test
    fun `Serial number should be autogenerated`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assert(certificate.certificateHolder.serialNumber > BigInteger.ZERO)
    }

    @Test
    fun `Validity start date should be set to current time by default`() {
        val certificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(
            Date.valueOf(LocalDate.now()),
            certificate.certificateHolder.notBefore
        )
    }

    // TODO: There shouldn't be any default end date. It must be explicit.
    @Test
    fun testShouldHaveAValidDefaultEndDate() {
        val newCertificate = Certificate.issue(
            stubCommonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertTrue(
            newCertificate.certificateHolder.notAfter > Date.valueOf(LocalDate.now()),
            "Should create a certificate end date after now"
        )
    }

    @Test
    fun `The end date should be later than the start date`() {
        val validityStartDate = LocalDateTime.now().plusMonths(1)

        val exception = assertThrows<CertificateException> {
            Certificate.issue(
                stubCommonName,
                stubKeyPair.private,
                stubKeyPair.public,
                validityStartDate,
                validityStartDate // Same as start date
            )
        }
        assertEquals(
            "The end date must be later than the start date",
            exception.message
        )
    }

    @Test
    fun `Subject DN should be set to specified CN`() {
        val commonName = "The CN"
        val certificate = Certificate.issue(
            commonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(1, certificate.certificateHolder.subject.rdNs.size)
        assertEquals(false, certificate.certificateHolder.subject.rdNs[0].isMultiValued)
        assertEquals(commonName, certificate.certificateHolder.subject.rdNs[0].first.value.toString())
    }

    @Test
    fun `Issuer DN should be same as subject when certificate is self-issued`() {
        val commonName = "The CN"
        val certificate = Certificate.issue(
            commonName,
            stubKeyPair.private,
            stubKeyPair.public
        )

        assertEquals(1, certificate.certificateHolder.issuer.rdNs.size)
        assertEquals(false, certificate.certificateHolder.issuer.rdNs[0].isMultiValued)
        assertEquals(commonName, certificate.certificateHolder.issuer.rdNs[0].first.value.toString())
    }

    @Nested
    inner class IssuerCertificate {
        @Test
        @Disabled
        fun `Issuer DN should be set to subject of issuer certificate`() {
        }

        @Test
        @Disabled
        fun `Issuer certificate should have basicConstraints extension`() {
        }

        @Test
        @Disabled
        fun `Issuer certificate should be marked as CA`() {
        }
    }

    @Nested
    inner class BasicConstraintsExtension {
        @Test
        @Disabled
        fun `Extension should be included and marked as critical`() {
        }

        @Test
        @Disabled
        fun `CA flag should be false by default`() {
        }

        @Test
        @Disabled
        fun `CA flag should be enabled if requested`() {
        }

        @Test
        @Disabled
        fun `pathLenConstraint should be 0 by default`() {
        }

        @Test
        @Disabled
        fun `pathLenConstraint can be set to a custom value less than or equal to 2`() {
        }

        @Test
        @Disabled
        fun `pathLenConstraint should not be greater than 2`() {
        }

        @Test
        @Disabled
        fun `pathLenConstraint should not be negative`() {
        }

        @Nested
        inner class AuthorityKeyIdentifier {
            @Test
            @Disabled
            fun `Value should correspond to subject when self-issued`() {
            }

            @Test
            @Disabled
            fun `Value should correspond to issuer when issued by a CA`() {
            }
        }

        @Test
        @Disabled
        fun `Subject Key Identifier extension should correspond to subject key`() {
        }
    }
}
